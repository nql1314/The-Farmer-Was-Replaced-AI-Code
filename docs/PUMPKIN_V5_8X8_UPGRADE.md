# Pumpkin V5 - 8x8中心区域升级

## 概述
将 pumpkin_v5.py 中的32x32农场布局从"16个6x6区域"改进为"12个6x6区域 + 4个8x8中心区域"。

## 农场布局变化

### 原布局（16个6x6区域）
```
32x32农场，均匀分成16个6x6区域
- 总区域：16个
- 单区域大小：6x6 = 36格
- 总格子数：16 × 36 = 576格
- 无人机数：32个（每区域2个）
```

### 新布局（12个6x6 + 4个8x8）✅ 已修正
```
32x32农场：
- 边缘区域：12个 6x6区域
- 中心区域：4个 8x8区域
  
6x6区域位置（12个）：
- (0,0), (0,7), (0,19), (0,26)     - 顶部一排
  覆盖：x=0-5, y=0-5/7-12/19-24/26-31
  
- (7,0), (7,26)                     - 左侧中间
  覆盖：x=7-12, y=0-5/26-31
  
- (20,0), (20,26)                   - 右侧中间
  覆盖：x=20-25, y=0-5/26-31
  
- (26,0), (26,7), (26,20), (26,26) - 底部一排
  覆盖：x=26-31, y=0-5/7-12/20-25/26-31

8x8区域位置（4个中心）：
- (6,6)   → 覆盖 x=6-13, y=6-13    左上中心
- (6,18)  → 覆盖 x=6-13, y=18-25   左下中心
- (18,6)  → 覆盖 x=18-25, y=6-13   右上中心
- (18,18) → 覆盖 x=18-25, y=18-25  右下中心

布局验证：
- 顶部行：y=0-5 (6x6×4)
- 上中区：y=6-13 (6x6×2 + 8x8×2)
- 中间行：y=14-17 空隙？
- 下中区：y=18-25 (6x6×2 + 8x8×2)
- 底部行：y=26-31 (6x6×4)

⚠️ 发现y=14-17有4行空隙未覆盖！
```

## 代码结构变化

### 1. 路径定义分离
```python
# 原来：只有一个PATH
PATH = {...}  # 6x6路径

# 现在：分成两个PATH
PATH_6X6 = {...}  # 6x6路径（18格）
PATH_8X8 = {...}  # 8x8路径（32格）
```

### 2. 共享内存结构
```python
# 新增type字段标识区域类型
{
    (x, y): {
        'ready': False,
        'unverified_left': [],
        'unverified_right': [],
        'help_flag': False,
        'type': '6x6' 或 '8x8'  # 新增
    }
}

# 分离的活跃无人机列表
"left_active_drones_6x6": [...]   # 6x6区域的左无人机
"right_active_drones_6x6": [...]  # 6x6区域的右无人机
"left_active_drones_8x8": [...]   # 8x8区域的左无人机
"right_active_drones_8x8": [...]  # 8x8区域的右无人机
```

### 3. 函数分离

#### Helper函数
- `get_next_region_6x6()` - 获取下一个6x6区域
- `get_next_region_8x8()` - 获取下一个8x8区域
- `final_round_helper_6x6()` - 6x6区域最终轮帮助
- `final_round_helper_8x8()` - 8x8区域最终轮帮助

#### Verify函数
- `verify_left_6x6()` - 验证6x6左半区域
- `verify_right_6x6()` - 验证6x6右半区域（start_x = region_x + 3）
- `verify_left_8x8()` - 验证8x8左半区域
- `verify_right_8x8()` - 验证8x8右半区域（start_x = region_x + 4）

#### Worker函数
- `create_worker_left_6x6()` - 6x6区域左工人
- `create_worker_right_6x6()` - 6x6区域右工人
- `create_worker_left_8x8()` - 8x8区域左工人
- `create_worker_right_8x8()` - 8x8区域右工人

### 4. 主程序
```python
# 6x6区域：12个工人
worker1-12: create_worker_left_6x6(...)

# 8x8区域：4个工人
worker13-16: create_worker_left_8x8(...)
```

## 关键差异

### 6x6区域
- 路径：PATH_6X6（18格）
- 左半：3列 × 6行
- 右半起始：region_x + 3
- 左半右边界：region_x + 2

### 8x8区域
- 路径：PATH_8X8（32格）
- 左半：4列 × 8行
- 右半起始：region_x + 4
- 左半右边界：region_x + 3

## 预期优势

### 1. 更大的合并区域
- 8x8 = 64格，可形成更大的南瓜合并块
- 6x6 = 36格

### 2. 中心区域优化
- 中心区域通常更稳定（更少边界问题）
- 更大的区域减少边界协调开销

### 3. 更高效的收获
- 8×8 = 512个南瓜（如果完美合并）
- 6×6 = 216个南瓜（如果完美合并）
- 4个8x8区域理论产量：2048
- vs 4个6x6区域理论产量：864
- 提升：137%！

## 设计原则

### 完全分离
- 6x6和8x8的函数**完全独立**
- 没有共享的逻辑代码
- 每个函数都明确使用对应的PATH
- 避免相互干扰

### 只共享不可变的
- `loop_verify()` - 通用的验证循环（不涉及路径）
- `help()` - 通用的帮助函数（不涉及路径）
- `WATER_THRESHOLD`, `TARGET` 等常量

## 潜在问题

### 1. 布局冲突
需要验证8x8区域的位置是否与6x6区域重叠：
- 6x6区域：(7,7), (7,19), (19,7), (19,19) 被移除
- 8x8区域：(12,12), (12,24), (24,12), (24,24) 替代

布局计算：
```
6x6区域占用：
- (0,0)→(5,5), (0,7)→(5,12), (0,19)→(5,24), (0,26)→(5,31)
- (7,0)→(12,5), (7,26)→(12,31)
- (19,0)→(24,5), (19,26)→(24,31)
- (26,0)→(31,5), (26,7)→(31,12), (26,19)→(31,24), (26,26)→(31,31)

8x8区域占用：
- (12,12)→(19,19), (12,24)→(19,31)
- (24,12)→(31,19), (24,24)→(31,31)

⚠️ 发现重叠！
- 8x8区域 (12,24)→(19,31) 与 6x6区域 (19,26)→(24,31) 重叠
- 8x8区域 (24,12)→(31,19) 与 6x6区域 (26,7)→(31,12) 重叠
- 8x8区域 (24,24)→(31,31) 与 6x6区域 (26,26)→(31,31) 重叠
```

### 2. 修正建议
需要重新调整区域位置，避免重叠。建议方案：

#### 方案A：调整8x8位置
```
8x8区域改为：
- (6,6)→(13,13)    # 左上
- (6,18)→(13,25)   # 左下
- (18,6)→(25,13)   # 右上
- (18,18)→(25,25)  # 右下
```

#### 方案B：调整6x6布局
移除部分6x6区域，为8x8腾出空间。

## 后续步骤

1. ✅ 代码结构完成
2. ⚠️ 需要验证布局无重叠
3. ⏳ 测试运行
4. ⏳ 性能对比
5. ⏳ 优化调整

## 测试计划

1. 检查所有16个工人是否正常启动
2. 验证无人机不会相互干扰
3. 确认8x8区域的PATH正确性
4. 对比v4和v5的总产量
5. 测量达到TARGET的时间差异

